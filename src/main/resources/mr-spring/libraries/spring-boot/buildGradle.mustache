/*
 * Copyright 2017 My Company. All rights reserved.
 */

buildscript {
    repositories {
        maven {
            url "https://hc-us-east-aws-artifactory.cloud.health.ge.com/artifactory/maven-ext"
        }
    }
    dependencies {
        classpath 'org.springframework.boot:spring-boot-gradle-plugin:1.5.+'
    }
}

plugins {
    id 'idea'
    id 'org.sonarqube' version '2.4'
    id 'com.jfrog.artifactory' version '4.4.13'
    id 'maven-publish'
}

allprojects {
    repositories {
        maven {
            url "https://hc-us-east-aws-artifactory.cloud.health.ge.com/artifactory/maven-ext"
        }
    }
    apply plugin: 'java'
}

def cucumberVersion = '1.2.+'
def javaxValidationVersion = '1.1.0.Final'
def powerMockVersion = '1.6.+'
def springFoxVersion = '2.6.+'
def springBootVersion = '1.5.+'
def swaggerVersion = '1.5.+'
def swaggerCodegenVersion = '2.+'

group 'com.ge.med.mr.{{serviceName}}'

subprojects {
    apply plugin: 'jacoco'

    sourceCompatibility = 1.8
    targetCompatibility = 1.8

    tasks.withType(JavaCompile) {
        options.compilerArgs += '-Xlint'
        options.compilerArgs += '-Werror'
    }

    version '1.0.0-SNAPSHOT'
}

project(':') {
    apply plugin: 'base'

    task runsonar {
        doLast {
            println "Sonar Report link : " + project.buildDir + "/sonar/issues-report/issues-report.html"
        }
    }
    project.tasks["runsonar"].dependsOn "sonarqube"

    sonarqube {
        properties {
            property "sonar.exclusions", "**/model/**"
        }
    }

    publishing {
        publications {
            {{serviceName}}(MavenPublication) {
                artifactId '{{serviceName}}'
                version = 'v1'
                artifact '{{serviceName}}.yaml'
            }
        }
    }
    artifactory {
        contextUrl = project.properties["artifactory_contextUrl"] ?: "Artifactory URL not set"
        publish {
            repository {
                // The Artifactory repository key to publish to
                repoKey = 'maven-release-mr'
                username = project.properties["artifactory_user"] ?: "Artifactory User"
                password = project.properties["artifactory_password"] ?: "Artifactory Password"
                maven = true
            }
            defaults {
                publishArtifacts = true
                publications('{{serviceName}}')
                publishPom = true //Publish generated POM files to Artifactory (true by default)
                publishIvy = false //Publish generated Ivy descriptor files to Artifactory (true by default)
                properties {
                    // This adds a property of content-type to each yaml artifact published with the value of
                    // application/yaml.  This is necessary so that when doing a get on the artifact url directly, the
                    // artifactory server will set the content-type correctly.
                    all 'com.ge.med.mr:*:*:*@yaml', 'artifactory.content-type': 'application/yaml'
                }
            }
        }
    }
    artifactoryPublish {
        publications('{{serviceName}}')
    }
}

project(':{{serviceName}}-api') {

    configurations {
        swagger
    }

    dependencies {
        compile('io.swagger:swagger-annotations:' + swaggerVersion)
        compile('io.springfox:springfox-swagger2:' + springFoxVersion)
        compile('javax.validation:validation-api:' + javaxValidationVersion)
        swagger('io.swagger:swagger-codegen-cli:' + swaggerCodegenVersion)
    }

    task copySwaggerCodegen(type: Copy) {
        from configurations.swagger
        into "$buildDir"
        rename "swagger-codegen-cli-.*.jar", "swagger-codegen-cli.jar"
    }

    task cleanGeneratedDirectory(type: Delete) {
        delete "$projectDir/src/main/java/com/ge/med/mr/{{serviceName}}/model"
    }
    clean.dependsOn cleanGeneratedDirectory

    task generateModels(type: Exec, dependsOn: copySwaggerCodegen) {
        def specs = file("$projectDir/../{{serviceName}}.yaml")
        commandLine 'java', '-jar', '-Dmodels', 'build/swagger-codegen-cli.jar', 'generate', '-i', specs.absolutePath,
                '-l', 'spring', '--model-package', 'com.ge.med.mr.{{serviceName}}.model'
    }
    compileJava.dependsOn generateModels
}

project(':{{serviceName}}-impl') {
    dependencies {
        compile project(':{{serviceName}}-api')

        compile('org.springframework.boot:spring-boot-starter:' + springBootVersion)
        compile('org.springframework.boot:spring-boot-starter-aop:' + springBootVersion)
        compile('org.springframework.boot:spring-boot-starter-web:' + springBootVersion)

        testCompile('info.cukes:cucumber-java8:' + cucumberVersion)
        testCompile('info.cukes:cucumber-junit:' + cucumberVersion)
        testCompile('info.cukes:cucumber-spring:' + cucumberVersion)
        testCompile('org.springframework.boot:spring-boot-starter-test:' + springBootVersion)
        testCompile('org.powermock:powermock-api-mockito:' + powerMockVersion)
        testCompile('org.powermock:powermock-module-junit4:' + powerMockVersion)
    }
}

project(':{{serviceName}}-ws') {

    apply plugin: 'org.springframework.boot'

    bootRepackage {
        classifier = 'boot'
    }

    dependencies {
        compile project(':{{serviceName}}-api')

        compile('io.springfox:springfox-swagger2:' + springFoxVersion)
        compile('io.springfox:springfox-swagger-ui:' + springFoxVersion)
        compile('io.swagger:swagger-annotations:' + swaggerVersion)
        compile('org.springframework.boot:spring-boot-starter-web:' + springBootVersion)

        runtime project(':{{serviceName}}-impl')

        testCompile('info.cukes:cucumber-java8:' + cucumberVersion)
        testCompile('info.cukes:cucumber-junit:' + cucumberVersion)
        testCompile('info.cukes:cucumber-spring:' + cucumberVersion)
        testCompile('org.powermock:powermock-api-mockito:' + powerMockVersion)
        testCompile('org.powermock:powermock-module-junit4:' + powerMockVersion)
        testCompile('org.springframework.boot:spring-boot-starter-test:' + springBootVersion)
    }
}

// This final section is for generating all of the Javadoc from our multiple projects into a single directory.

def exportedProjects = [
        ":{{serviceName}}-api",
        ":{{serviceName}}-impl",
        ":{{serviceName}}-ws"
]

task alljavadoc(type: Javadoc) {
    source = exportedProjects.collect { project(it).sourceSets.main.allJava }
    classpath = files(exportedProjects.collect { project(it).sourceSets.main.compileClasspath })
    destinationDir = file("${buildDir}/docs/javadoc/{{serviceName}}-service")
}

task publishjavadoc(type: Copy, dependsOn: alljavadoc) {
    try {
        // Delete any existing JavaDoc in the destination directory
        File destDir = file(project.properties.get('docDestDir') + '/{{serviceName}}-service')
        delete(destDir)
        // Copy JavaDoc published by the task "alljavadoc" to the destination directory
        from "${buildDir}/docs/javadoc/{{serviceName}}-service"
        into project.properties.get('docDestDir') + '/{{serviceName}}-service'
    }
    catch (Exception e) {
        println e
    }
}
